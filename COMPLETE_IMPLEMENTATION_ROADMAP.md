# ğŸš€ Ù†Ù‚Ø´Ù‡ Ø±Ø§Ù‡ Ú©Ø§Ù…Ù„ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Backend Ø¨Ø±Ø§ÛŒ Ø³Ø§ÛŒØª zala.ir

**Ù‡Ø¯Ù**: Ú©Ø§Ù…Ù„ Ú©Ø±Ø¯Ù† Backend ØªØ§ 100% Ø¨Ø§ Frontend Ù‡Ù…Ø§Ù‡Ù†Ú¯ Ø´ÙˆØ¯

**ØªØ®Ù…ÛŒÙ† Ø²Ù…Ø§Ù† Ú©Ù„**: 2-3 Ù‡ÙØªÙ‡ (Ø¨Ø§ ÛŒÚ© Ù†ÙØ± Full-time)

**ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Task Ù‡Ø§**: 67 Task Ø¯Ø± 8 ÙØ§Ø²

---

## ğŸ“Š Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Frontend - Ú†Ù‡ Ú†ÛŒØ²ÛŒ Ø¯Ø§Ø±ÛŒÙ…ØŸ

### Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Frontend:

```
Frontend Ù…ÙˆØ¬ÙˆØ¯:
â”œâ”€â”€ ğŸ¨ UI Components (100% Ø¢Ù…Ø§Ø¯Ù‡)
â”‚   â”œâ”€â”€ Login/Register Forms
â”‚   â”œâ”€â”€ Dashboard Widgets (15+ widget)
â”‚   â”œâ”€â”€ Trading Interface
â”‚   â”œâ”€â”€ Portfolio View
â”‚   â”œâ”€â”€ Market Data Display
â”‚   â”œâ”€â”€ AI Agents Section (15 agents)
â”‚   â”œâ”€â”€ Alerts & Notifications
â”‚   â”œâ”€â”€ Settings Panel
â”‚   â””â”€â”€ Charts (Chart.js)
â”‚
â”œâ”€â”€ ğŸ“¡ API Integration Layer (Ø¢Ù…Ø§Ø¯Ù‡ ÙˆÙ„ÛŒ Backend Ù†Ø¯Ø§Ø±Ø¯)
â”‚   â”œâ”€â”€ HTTP Client Ø¨Ø§ Circuit Breaker
â”‚   â”œâ”€â”€ Data Adapters (4 adapters)
â”‚   â”œâ”€â”€ Metadata Validation
â”‚   â””â”€â”€ NO-DATA UI Handler
â”‚
â”œâ”€â”€ ğŸ¤– AI Agents (15 agents - Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ ÙˆÙ„ÛŒ Ú©Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯)
â”‚   â”œâ”€â”€ Agent 01: Technical Analysis
â”‚   â”œâ”€â”€ Agent 02: Risk Management
â”‚   â”œâ”€â”€ Agent 03: Sentiment Analysis
â”‚   â”œâ”€â”€ Agent 04: Portfolio Optimization
â”‚   â”œâ”€â”€ Agent 05: Market Making
â”‚   â”œâ”€â”€ Agent 06: Algorithmic Trading
â”‚   â”œâ”€â”€ Agent 07: News Analysis
â”‚   â”œâ”€â”€ Agent 08: HFT (High Frequency Trading)
â”‚   â”œâ”€â”€ Agent 09: Quantitative Analysis
â”‚   â”œâ”€â”€ Agent 10: Macro Analysis
â”‚   â”œâ”€â”€ Agent 11-15: (Other specialized agents)
â”‚   â””â”€â”€ Ù‡Ù…Ù‡ Ù…Ù†ØªØ¸Ø± Backend API Ù‡Ø§ Ù‡Ø³ØªÙ†Ø¯!
â”‚
â””â”€â”€ ğŸ”’ Security & Validation (100% Ø¢Ù…Ø§Ø¯Ù‡)
    â”œâ”€â”€ FORCE_REAL Flag
    â”œâ”€â”€ Metadata Signatures
    â”œâ”€â”€ Stale Data Detection
    â””â”€â”€ Circuit Breaker
```

---

## ğŸ¯ ÙØ§Ø² 1: Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Backend (Ø±ÙˆØ² 1)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 1 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§  
**ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒ**: Ù‡ÛŒÚ†

### Task 1.1: Setup Ø¯ÛŒØªØ§Ø¨ÛŒØ³ (2 Ø³Ø§Ø¹Øª)

#### Ù‚Ø¯Ù… 1: Ø§Ù†ØªØ®Ø§Ø¨ Database Schema

**ÙØ§ÛŒÙ„**: `schema.prisma` (Ø§Ú¯Ø± Prisma Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯)

```prisma
// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"  // ÛŒØ§ sqlite Ø¨Ø±Ø§ÛŒ development
  url      = env("DATABASE_URL")
}

// ğŸ‘¤ Users Table
model User {
  id                String    @id @default(cuid())
  username          String    @unique
  email             String    @unique
  password          String    // hashed
  firstName         String?
  lastName          String?
  role              String    @default("user")
  isActive          Boolean   @default(true)
  isVerified        Boolean   @default(false)
  twoFactorEnabled  Boolean   @default(false)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  portfolio         Portfolio?
  trades            Trade[]
  alerts            Alert[]
  sessions          Session[]
}

// ğŸ’° Portfolio Table
model Portfolio {
  id            String          @id @default(cuid())
  userId        String          @unique
  user          User            @relation(fields: [userId], references: [id])
  totalBalance  Float           @default(0)
  totalValue    Float           @default(0)
  totalPnL      Float           @default(0)
  dailyChange   Float           @default(0)
  weeklyChange  Float           @default(0)
  monthlyChange Float           @default(0)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  // Relations
  assets        PortfolioAsset[]
}

// ğŸ’ Portfolio Assets
model PortfolioAsset {
  id            String    @id @default(cuid())
  portfolioId   String
  portfolio     Portfolio @relation(fields: [portfolioId], references: [id])
  symbol        String    // BTC, ETH, etc.
  amount        Float
  avgBuyPrice   Float
  currentPrice  Float
  totalValue    Float
  pnl           Float
  pnlPercent    Float
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@unique([portfolioId, symbol])
}

// ğŸ“Š Trades Table
model Trade {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  type          String    // buy, sell
  symbol        String    // BTCUSDT
  amount        Float
  price         Float
  total         Float
  fee           Float
  status        String    @default("pending") // pending, completed, failed, cancelled
  strategy      String?   // manual, agent_01, agent_02, etc.
  agentId       String?
  
  // Market Order Details
  orderType     String    @default("market") // market, limit, stop_loss
  stopPrice     Float?
  limitPrice    Float?
  
  // Timestamps
  placedAt      DateTime  @default(now())
  executedAt    DateTime?
  cancelledAt   DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ğŸ“ˆ Market Data (Cache)
model MarketData {
  id            String    @id @default(cuid())
  symbol        String    @unique
  price         Float
  change24h     Float
  volume24h     Float
  high24h       Float
  low24h        Float
  marketCap     Float?
  lastUpdate    DateTime  @default(now())
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ğŸ”” Alerts Table
model Alert {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  type          String    // price, indicator, news
  symbol        String?
  condition     String    // above, below, crosses
  targetValue   Float?
  currentValue  Float?
  isActive      Boolean   @default(true)
  isTriggered   Boolean   @default(false)
  triggeredAt   DateTime?
  message       String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ğŸ¤– AI Signals
model AISignal {
  id            String    @id @default(cuid())
  agentId       String    // AGENT_01, AGENT_02, etc.
  symbol        String
  action        String    // buy, sell, hold
  confidence    Float     // 0-1
  price         Float
  reason        String?
  indicators    Json?     // ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªÚ©Ù†ÛŒÚ©Ø§Ù„
  isValid       Boolean   @default(true)
  expiresAt     DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ğŸ“± Sessions (Ø¨Ø±Ø§ÛŒ authentication)
model Session {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  token         String    @unique
  ipAddress     String?
  userAgent     String?
  expiresAt     DateTime
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}
```

#### Ù‚Ø¯Ù… 2: Ø§Ø¬Ø±Ø§ÛŒ Migration

```bash
# Ù†ØµØ¨ Prisma (Ø§Ú¯Ø± Ù†ØµØ¨ Ù†ÛŒØ³Øª)
npm install prisma @prisma/client

# Ø§ÛŒØ¬Ø§Ø¯ migration
npx prisma migrate dev --name init

# Generate Prisma Client
npx prisma generate
```

#### Ù‚Ø¯Ù… 3: Seed Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡

**ÙØ§ÛŒÙ„**: `prisma/seed.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'

const prisma = new PrismaClient()

async function main() {
  console.log('ğŸŒ± Seeding database...')
  
  // Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø± ØªØ³ØªÛŒ
  const hashedPassword = await bcrypt.hash('admin', 10)
  
  const adminUser = await prisma.user.upsert({
    where: { username: 'admin' },
    update: {},
    create: {
      username: 'admin',
      email: 'admin@zala.ir',
      password: hashedPassword,
      firstName: 'Admin',
      lastName: 'User',
      role: 'admin',
      isActive: true,
      isVerified: true,
    }
  })
  
  console.log('âœ… Admin user created:', adminUser.username)
  
  // Ø§ÛŒØ¬Ø§Ø¯ Portfolio Ø¨Ø±Ø§ÛŒ admin
  const portfolio = await prisma.portfolio.upsert({
    where: { userId: adminUser.id },
    update: {},
    create: {
      userId: adminUser.id,
      totalBalance: 100000, // $100k initial
      totalValue: 100000,
      totalPnL: 0,
      dailyChange: 0,
    }
  })
  
  console.log('âœ… Portfolio created for admin')
  
  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú†Ù†Ø¯ Asset
  const assets = [
    { symbol: 'BTC', amount: 1.5, avgBuyPrice: 40000 },
    { symbol: 'ETH', amount: 20, avgBuyPrice: 2500 },
    { symbol: 'BNB', amount: 100, avgBuyPrice: 300 },
  ]
  
  for (const asset of assets) {
    await prisma.portfolioAsset.create({
      data: {
        portfolioId: portfolio.id,
        ...asset,
        currentPrice: asset.avgBuyPrice * 1.1, // 10% profit
        totalValue: asset.amount * asset.avgBuyPrice * 1.1,
        pnl: asset.amount * asset.avgBuyPrice * 0.1,
        pnlPercent: 10,
      }
    })
  }
  
  console.log('âœ… Assets added to portfolio')
  
  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Market Data
  const marketData = [
    { symbol: 'BTCUSDT', price: 43250, change24h: 2.3, volume24h: 25000000000, high24h: 44000, low24h: 42000 },
    { symbol: 'ETHUSDT', price: 2680, change24h: 1.5, volume24h: 12000000000, high24h: 2700, low24h: 2600 },
    { symbol: 'BNBUSDT', price: 315, change24h: -0.8, volume24h: 3000000000, high24h: 320, low24h: 310 },
  ]
  
  for (const data of marketData) {
    await prisma.marketData.upsert({
      where: { symbol: data.symbol },
      update: data,
      create: data,
    })
  }
  
  console.log('âœ… Market data seeded')
  
  console.log('ğŸ‰ Seeding completed!')
}

main()
  .catch((e) => {
    console.error('âŒ Seeding failed:', e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

Ø§Ø¬Ø±Ø§ÛŒ Seed:
```bash
npx prisma db seed
```

---

### Task 1.2: Setup Authentication System (3 Ø³Ø§Ø¹Øª)

#### Ù‚Ø¯Ù… 1: Ø§ÛŒØ¬Ø§Ø¯ Auth Service

**ÙØ§ÛŒÙ„**: `src/services/auth-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'
import jwt from 'jsonwebtoken'

const prisma = new PrismaClient()

export class AuthService {
  private JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production'
  private JWT_EXPIRES_IN = '7d'
  
  /**
   * Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯
   */
  async register(data: {
    username: string
    email: string
    password: string
    firstName?: string
    lastName?: string
  }) {
    // Ú†Ú© Ú©Ø±Ø¯Ù† username ØªÚ©Ø±Ø§Ø±ÛŒ
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { username: data.username },
          { email: data.email }
        ]
      }
    })
    
    if (existingUser) {
      throw new Error('Username or email already exists')
    }
    
    // Hash Ú©Ø±Ø¯Ù† password
    const hashedPassword = await bcrypt.hash(data.password, 10)
    
    // Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±
    const user = await prisma.user.create({
      data: {
        username: data.username,
        email: data.email,
        password: hashedPassword,
        firstName: data.firstName,
        lastName: data.lastName,
      }
    })
    
    // Ø§ÛŒØ¬Ø§Ø¯ Portfolio Ø®Ø§Ù„ÛŒ
    await prisma.portfolio.create({
      data: {
        userId: user.id,
        totalBalance: 0,
        totalValue: 0,
      }
    })
    
    return {
      id: user.id,
      username: user.username,
      email: user.email,
    }
  }
  
  /**
   * ÙˆØ±ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø±
   */
  async login(username: string, password: string) {
    // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±
    const user = await prisma.user.findUnique({
      where: { username }
    })
    
    if (!user) {
      throw new Error('Invalid credentials')
    }
    
    // Ú†Ú© Ú©Ø±Ø¯Ù† password
    const isValidPassword = await bcrypt.compare(password, user.password)
    
    if (!isValidPassword) {
      throw new Error('Invalid credentials')
    }
    
    // Ú†Ú© Ú©Ø±Ø¯Ù† active Ø¨ÙˆØ¯Ù†
    if (!user.isActive) {
      throw new Error('Account is disabled')
    }
    
    // Ø³Ø§Ø®Øª JWT token
    const token = jwt.sign(
      {
        userId: user.id,
        username: user.username,
        role: user.role,
      },
      this.JWT_SECRET,
      { expiresIn: this.JWT_EXPIRES_IN }
    )
    
    // Ø°Ø®ÛŒØ±Ù‡ session
    await prisma.session.create({
      data: {
        userId: user.id,
        token,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      }
    })
    
    return {
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
      }
    }
  }
  
  /**
   * ØªØ£ÛŒÛŒØ¯ Token
   */
  async verifyToken(token: string) {
    try {
      // Decode token
      const decoded = jwt.verify(token, this.JWT_SECRET) as any
      
      // Ú†Ú© Ú©Ø±Ø¯Ù† session
      const session = await prisma.session.findFirst({
        where: {
          token,
          expiresAt: { gte: new Date() }
        },
        include: {
          user: true
        }
      })
      
      if (!session) {
        throw new Error('Invalid or expired session')
      }
      
      return {
        userId: session.user.id,
        username: session.user.username,
        role: session.user.role,
      }
    } catch (error) {
      throw new Error('Invalid token')
    }
  }
  
  /**
   * Ø®Ø±ÙˆØ¬ Ú©Ø§Ø±Ø¨Ø±
   */
  async logout(token: string) {
    await prisma.session.deleteMany({
      where: { token }
    })
  }
}

export const authService = new AuthService()
```

#### Ù‚Ø¯Ù… 2: Ø§ÛŒØ¬Ø§Ø¯ Auth Middleware

**ÙØ§ÛŒÙ„**: `src/middleware/auth.ts`

```typescript
import { Context, Next } from 'hono'
import { authService } from '../services/auth-service'

export async function authMiddleware(c: Context, next: Next) {
  try {
    const authorization = c.req.header('Authorization')
    
    if (!authorization || !authorization.startsWith('Bearer ')) {
      return c.json({ 
        success: false, 
        error: 'Authentication required' 
      }, 401)
    }
    
    const token = authorization.substring(7)
    
    // ØªØ£ÛŒÛŒØ¯ token
    const user = await authService.verifyToken(token)
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† user Ø¨Ù‡ context
    c.set('user', user)
    
    await next()
  } catch (error) {
    return c.json({ 
      success: false, 
      error: 'Invalid or expired token' 
    }, 401)
  }
}
```

#### Ù‚Ø¯Ù… 3: Ø§ÛŒØ¬Ø§Ø¯ Auth Routes

**ÙØ§ÛŒÙ„**: `src/routes/auth.ts`

```typescript
import { Hono } from 'hono'
import { authService } from '../services/auth-service'

const auth = new Hono()

// Register
auth.post('/register', async (c) => {
  try {
    const body = await c.req.json()
    
    const user = await authService.register(body)
    
    return c.json({
      success: true,
      message: 'Registration successful',
      data: user
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// Login
auth.post('/login', async (c) => {
  try {
    const { username, password } = await c.req.json()
    
    const result = await authService.login(username, password)
    
    return c.json({
      success: true,
      message: 'Login successful',
      data: result
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 401)
  }
})

// Logout
auth.post('/logout', async (c) => {
  try {
    const authorization = c.req.header('Authorization')
    const token = authorization?.substring(7)
    
    if (token) {
      await authService.logout(token)
    }
    
    return c.json({
      success: true,
      message: 'Logged out successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// Get current user
auth.get('/me', async (c) => {
  try {
    const authorization = c.req.header('Authorization')
    const token = authorization?.substring(7)
    
    if (!token) {
      return c.json({ success: false, error: 'No token provided' }, 401)
    }
    
    const user = await authService.verifyToken(token)
    
    return c.json({
      success: true,
      data: user
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 401)
  }
})

export default auth
```

---

## ğŸ¯ ÙØ§Ø² 2: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Portfolio APIs (Ø±ÙˆØ² 2-3)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 2 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§

### Task 2.1: Portfolio Service (4 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/portfolio-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export class PortfolioService {
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Portfolio Ú©Ø§Ù…Ù„
   */
  async getPortfolio(userId: string) {
    const portfolio = await prisma.portfolio.findUnique({
      where: { userId },
      include: {
        assets: true
      }
    })
    
    if (!portfolio) {
      throw new Error('Portfolio not found')
    }
    
    return portfolio
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Portfolio Advanced (Ø¨Ø±Ø§ÛŒ Dashboard)
   */
  async getAdvancedPortfolio(userId: string) {
    const portfolio = await this.getPortfolio(userId)
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù…Ø§Ø±Ù‡Ø§
    const totalAssets = portfolio.assets.length
    const totalInvested = portfolio.assets.reduce((sum, asset) => 
      sum + (asset.amount * asset.avgBuyPrice), 0
    )
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Win Rate (Ø§Ø² trade Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ)
    const completedTrades = await prisma.trade.count({
      where: { 
        userId,
        status: 'completed'
      }
    })
    
    const profitableTrades = await prisma.trade.count({
      where: {
        userId,
        status: 'completed',
        pnl: { gt: 0 }
      }
    })
    
    const winRate = completedTrades > 0 
      ? (profitableTrades / completedTrades) * 100 
      : 0
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Sharpe Ratio (Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
    const sharpeRatio = portfolio.totalPnL > 0 
      ? (portfolio.totalPnL / totalInvested) * Math.sqrt(252)
      : 0
    
    return {
      totalBalance: portfolio.totalBalance,
      totalValue: portfolio.totalValue,
      totalPnL: portfolio.totalPnL,
      pnlPercent: totalInvested > 0 ? (portfolio.totalPnL / totalInvested) * 100 : 0,
      dailyChange: portfolio.dailyChange,
      weeklyChange: portfolio.weeklyChange,
      monthlyChange: portfolio.monthlyChange,
      totalAssets,
      totalInvested,
      winRate: Math.round(winRate),
      sharpeRatio: Number(sharpeRatio.toFixed(2)),
      assets: portfolio.assets.map(asset => ({
        symbol: asset.symbol,
        amount: asset.amount,
        avgBuyPrice: asset.avgBuyPrice,
        currentPrice: asset.currentPrice,
        totalValue: asset.totalValue,
        pnl: asset.pnl,
        pnlPercent: asset.pnlPercent,
        allocation: (asset.totalValue / portfolio.totalValue) * 100
      }))
    }
  }
  
  /**
   * Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Portfolio
   */
  async updatePrices(userId: string, prices: Record<string, number>) {
    const portfolio = await this.getPortfolio(userId)
    
    let totalValue = portfolio.totalBalance
    let totalPnL = 0
    
    for (const asset of portfolio.assets) {
      const newPrice = prices[asset.symbol] || asset.currentPrice
      const newValue = asset.amount * newPrice
      const assetPnL = newValue - (asset.amount * asset.avgBuyPrice)
      const assetPnLPercent = ((newPrice - asset.avgBuyPrice) / asset.avgBuyPrice) * 100
      
      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ asset
      await prisma.portfolioAsset.update({
        where: { id: asset.id },
        data: {
          currentPrice: newPrice,
          totalValue: newValue,
          pnl: assetPnL,
          pnlPercent: assetPnLPercent
        }
      })
      
      totalValue += newValue
      totalPnL += assetPnL
    }
    
    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ portfolio
    await prisma.portfolio.update({
      where: { id: portfolio.id },
      data: {
        totalValue,
        totalPnL
      }
    })
    
    return { totalValue, totalPnL }
  }
  
  /**
   * Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Asset Ø¬Ø¯ÛŒØ¯
   */
  async addAsset(userId: string, data: {
    symbol: string
    amount: number
    price: number
  }) {
    const portfolio = await this.getPortfolio(userId)
    
    // Ú†Ú© Ú©Ø±Ø¯Ù† Asset Ù…ÙˆØ¬ÙˆØ¯
    const existingAsset = await prisma.portfolioAsset.findUnique({
      where: {
        portfolioId_symbol: {
          portfolioId: portfolio.id,
          symbol: data.symbol
        }
      }
    })
    
    if (existingAsset) {
      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Asset Ù…ÙˆØ¬ÙˆØ¯
      const newAmount = existingAsset.amount + data.amount
      const newAvgPrice = (
        (existingAsset.amount * existingAsset.avgBuyPrice) + 
        (data.amount * data.price)
      ) / newAmount
      
      return await prisma.portfolioAsset.update({
        where: { id: existingAsset.id },
        data: {
          amount: newAmount,
          avgBuyPrice: newAvgPrice,
          totalValue: newAmount * data.price
        }
      })
    } else {
      // Ø§ÛŒØ¬Ø§Ø¯ Asset Ø¬Ø¯ÛŒØ¯
      return await prisma.portfolioAsset.create({
        data: {
          portfolioId: portfolio.id,
          symbol: data.symbol,
          amount: data.amount,
          avgBuyPrice: data.price,
          currentPrice: data.price,
          totalValue: data.amount * data.price,
          pnl: 0,
          pnlPercent: 0
        }
      })
    }
  }
}

export const portfolioService = new PortfolioService()
```

### Task 2.2: Portfolio Routes (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/portfolio.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { portfolioService } from '../services/portfolio-service'

const portfolio = new Hono()

// Ù‡Ù…Ù‡ route Ù‡Ø§ Ù†ÛŒØ§Ø² Ø¨Ù‡ authentication Ø¯Ø§Ø±Ù†Ø¯
portfolio.use('*', authMiddleware)

// GET /api/portfolio - Ø¯Ø±ÛŒØ§ÙØª Portfolio Ø³Ø§Ø¯Ù‡
portfolio.get('/', async (c) => {
  try {
    const user = c.get('user')
    const data = await portfolioService.getPortfolio(user.userId)
    
    return c.json({
      success: true,
      data,
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// GET /api/portfolio/advanced - Ø¯Ø±ÛŒØ§ÙØª Portfolio Ù¾ÛŒØ´Ø±ÙØªÙ‡
portfolio.get('/advanced', async (c) => {
  try {
    const user = c.get('user')
    const data = await portfolioService.getAdvancedPortfolio(user.userId)
    
    return c.json({
      success: true,
      data,
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// POST /api/portfolio/asset - Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Asset
portfolio.post('/asset', async (c) => {
  try {
    const user = c.get('user')
    const body = await c.req.json()
    
    const asset = await portfolioService.addAsset(user.userId, body)
    
    return c.json({
      success: true,
      data: asset,
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// GET /api/portfolio/transactions - Ø¯Ø±ÛŒØ§ÙØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§
portfolio.get('/transactions', async (c) => {
  try {
    const user = c.get('user')
    const status = c.req.query('status') || 'all'
    const limit = parseInt(c.req.query('limit') || '100')
    const sort = c.req.query('sort') || 'desc'
    
    const where: any = { userId: user.userId }
    if (status !== 'all') {
      where.status = status
    }
    
    const transactions = await prisma.trade.findMany({
      where,
      orderBy: { createdAt: sort as 'asc' | 'desc' },
      take: limit
    })
    
    return c.json({
      success: true,
      data: {
        transactions,
        total: transactions.length
      },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

export default portfolio
```

---

## ğŸ¯ ÙØ§Ø² 3: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Market Data APIs (Ø±ÙˆØ² 4-5)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 2 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø§Ù„Ø§

### Task 3.1: Market Data Service Ø¨Ø§ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Binance (6 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/market-data-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import axios from 'axios'

const prisma = new PrismaClient()

export class MarketDataService {
  private binanceAPI = 'https://api.binance.com/api/v3'
  private coinGeckoAPI = 'https://api.coingecko.com/api/v3'
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Real-time Ø§Ø² Binance
   */
  async fetchRealTimePrices(symbols: string[]) {
    const prices: Record<string, any> = {}
    
    for (const symbol of symbols) {
      try {
        // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø² Binance
        const response = await axios.get(`${this.binanceAPI}/ticker/24hr`, {
          params: { symbol }
        })
        
        const data = response.data
        
        prices[symbol] = {
          symbol,
          price: parseFloat(data.lastPrice),
          change24h: parseFloat(data.priceChangePercent),
          volume24h: parseFloat(data.volume),
          high24h: parseFloat(data.highPrice),
          low24h: parseFloat(data.lowPrice),
          lastUpdate: new Date()
        }
        
        // Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Cache
        await prisma.marketData.upsert({
          where: { symbol },
          update: prices[symbol],
          create: prices[symbol]
        })
        
      } catch (error) {
        console.error(`Failed to fetch ${symbol}:`, error)
        
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Cache
        const cached = await prisma.marketData.findUnique({
          where: { symbol }
        })
        
        if (cached) {
          prices[symbol] = cached
        }
      }
    }
    
    return prices
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Fear & Greed Index
   */
  async getFearGreedIndex() {
    try {
      const response = await axios.get('https://api.alternative.me/fng/')
      const data = response.data.data[0]
      
      return {
        value: parseInt(data.value),
        classification: data.value_classification,
        timestamp: new Date(parseInt(data.timestamp) * 1000)
      }
    } catch (error) {
      // Fallback
      return {
        value: 50,
        classification: 'Neutral',
        timestamp: new Date()
      }
    }
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Top Gainers/Losers
   */
  async getTrending() {
    try {
      const response = await axios.get(`${this.coinGeckoAPI}/search/trending`)
      return response.data.coins
    } catch (error) {
      return []
    }
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Ø§Ø®Ø¨Ø§Ø± Ø¨Ø§Ø²Ø§Ø±
   */
  async getMarketNews(limit: number = 10) {
    // Ø§ÛŒÙ† Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ÛŒÚ© News API ÙˆØµÙ„ Ø´ÙˆØ¯
    // Ù…Ø«Ù„Ø§Ù‹ CryptoPanic API ÛŒØ§ NewsAPI
    
    try {
      // Ù…Ø«Ø§Ù„ Ø¨Ø§ CryptoPanic
      const response = await axios.get('https://cryptopanic.com/api/v1/posts/', {
        params: {
          auth_token: process.env.CRYPTOPANIC_API_KEY,
          public: true,
          limit
        }
      })
      
      return response.data.results.map((item: any) => ({
        id: item.id,
        title: item.title,
        url: item.url,
        source: item.source.title,
        publishedAt: new Date(item.published_at),
        currencies: item.currencies?.map((c: any) => c.code) || []
      }))
    } catch (error) {
      console.error('Failed to fetch news:', error)
      return []
    }
  }
}

export const marketDataService = new MarketDataService()
```

### Task 3.2: Market Routes (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/market.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { marketDataService } from '../services/market-data-service'

const market = new Hono()

market.use('*', authMiddleware)

// POST /api/market/prices - Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§
market.post('/prices', async (c) => {
  try {
    const { symbols } = await c.req.json()
    
    const prices = await marketDataService.fetchRealTimePrices(symbols)
    
    return c.json({
      success: true,
      data: { prices },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 5000, // 5 seconds cache
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// GET /api/market/fear-greed - Fear & Greed Index
market.get('/fear-greed', async (c) => {
  try {
    const data = await marketDataService.getFearGreedIndex()
    
    return c.json({
      success: true,
      data,
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 60000, // 1 minute
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// GET /api/market/trending - Top Gainers/Losers
market.get('/trending', async (c) => {
  try {
    const data = await marketDataService.getTrending()
    
    return c.json({
      success: true,
      data,
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 300000, // 5 minutes
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

export default market
```

---

## ğŸ¯ ÙØ§Ø² 4: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Trading Engine (Ø±ÙˆØ² 6-8)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 3 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§

### Task 4.1: Trading Service (8 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/trading-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import { portfolioService } from './portfolio-service'
import { marketDataService } from './market-data-service'

const prisma = new PrismaClient()

export class TradingService {
  /**
   * Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ Ø®Ø±ÛŒØ¯/ÙØ±ÙˆØ´
   */
  async placeTrade(userId: string, data: {
    type: 'buy' | 'sell'
    symbol: string
    amount: number
    orderType: 'market' | 'limit' | 'stop_loss'
    price?: number
    stopPrice?: number
    strategy?: string
    agentId?: string
  }) {
    // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
    const prices = await marketDataService.fetchRealTimePrices([data.symbol])
    const currentPrice = prices[data.symbol]?.price || data.price || 0
    
    if (currentPrice === 0) {
      throw new Error('Unable to fetch current price')
    }
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¨Ù„Øº Ú©Ù„
    const total = data.amount * currentPrice
    const fee = total * 0.001 // 0.1% fee
    const totalWithFee = total + fee
    
    // Ú†Ú© Ú©Ø±Ø¯Ù† Ù…ÙˆØ¬ÙˆØ¯ÛŒ (Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯)
    if (data.type === 'buy') {
      const portfolio = await portfolioService.getPortfolio(userId)
      
      if (portfolio.totalBalance < totalWithFee) {
        throw new Error('Insufficient balance')
      }
      
      // Ú©Ø³Ø± Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ
      await prisma.portfolio.update({
        where: { id: portfolio.id },
        data: {
          totalBalance: portfolio.totalBalance - totalWithFee
        }
      })
    }
    
    // Ø«Ø¨Øª Trade
    const trade = await prisma.trade.create({
      data: {
        userId,
        type: data.type,
        symbol: data.symbol,
        amount: data.amount,
        price: currentPrice,
        total,
        fee,
        status: data.orderType === 'market' ? 'completed' : 'pending',
        orderType: data.orderType,
        stopPrice: data.stopPrice,
        limitPrice: data.price,
        strategy: data.strategy || 'manual',
        agentId: data.agentId,
        executedAt: data.orderType === 'market' ? new Date() : undefined
      }
    })
    
    // Ø§Ú¯Ø± Market Order Ø¨ÙˆØ¯ØŒ ÙÙˆØ±ÛŒ Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯
    if (data.orderType === 'market') {
      await this.executeTrade(trade.id)
    }
    
    return trade
  }
  
  /**
   * Ø§Ø¬Ø±Ø§ÛŒ Trade
   */
  async executeTrade(tradeId: string) {
    const trade = await prisma.trade.findUnique({
      where: { id: tradeId }
    })
    
    if (!trade) {
      throw new Error('Trade not found')
    }
    
    if (trade.status !== 'pending' && trade.status !== 'completed') {
      throw new Error('Trade cannot be executed')
    }
    
    if (trade.type === 'buy') {
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Portfolio
      await portfolioService.addAsset(trade.userId, {
        symbol: trade.symbol,
        amount: trade.amount,
        price: trade.price
      })
    } else if (trade.type === 'sell') {
      // Ú©Ø³Ø± Ø§Ø² Portfolio Ùˆ Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ Balance
      const portfolio = await portfolioService.getPortfolio(trade.userId)
      const asset = portfolio.assets.find(a => a.symbol === trade.symbol)
      
      if (!asset || asset.amount < trade.amount) {
        throw new Error('Insufficient asset balance')
      }
      
      // Ú©Ø³Ø± Ø§Ø² Asset
      await prisma.portfolioAsset.update({
        where: { id: asset.id },
        data: {
          amount: asset.amount - trade.amount
        }
      })
      
      // Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ Balance
      await prisma.portfolio.update({
        where: { id: portfolio.id },
        data: {
          totalBalance: portfolio.totalBalance + trade.total - trade.fee
        }
      })
    }
    
    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Trade
    await prisma.trade.update({
      where: { id: tradeId },
      data: {
        status: 'completed',
        executedAt: new Date()
      }
    })
  }
  
  /**
   * Ù„ØºÙˆ Trade
   */
  async cancelTrade(tradeId: string, userId: string) {
    const trade = await prisma.trade.findFirst({
      where: {
        id: tradeId,
        userId
      }
    })
    
    if (!trade) {
      throw new Error('Trade not found')
    }
    
    if (trade.status !== 'pending') {
      throw new Error('Only pending trades can be cancelled')
    }
    
    // Ø§Ú¯Ø± Ø®Ø±ÛŒØ¯ Ø¨ÙˆØ¯ØŒ Ù…Ø¨Ù„Øº Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†
    if (trade.type === 'buy') {
      const portfolio = await portfolioService.getPortfolio(userId)
      await prisma.portfolio.update({
        where: { id: portfolio.id },
        data: {
          totalBalance: portfolio.totalBalance + trade.total + trade.fee
        }
      })
    }
    
    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Trade
    await prisma.trade.update({
      where: { id: tradeId },
      data: {
        status: 'cancelled',
        cancelledAt: new Date()
      }
    })
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Trade Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
   */
  async getActiveTrades(userId: string) {
    return await prisma.trade.findMany({
      where: {
        userId,
        status: { in: ['pending', 'completed'] }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })
  }
}

export const tradingService = new TradingService()
```

### Task 4.2: Trading Routes (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/trading.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { tradingService } from '../services/trading-service'

const trading = new Hono()

trading.use('*', authMiddleware)

// POST /api/trading/order - Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´
trading.post('/order', async (c) => {
  try {
    const user = c.get('user')
    const body = await c.req.json()
    
    const trade = await tradingService.placeTrade(user.userId, body)
    
    return c.json({
      success: true,
      data: trade,
      message: 'Order placed successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// POST /api/trading/order/:id/cancel - Ù„ØºÙˆ Ø³ÙØ§Ø±Ø´
trading.post('/order/:id/cancel', async (c) => {
  try {
    const user = c.get('user')
    const tradeId = c.req.param('id')
    
    await tradingService.cancelTrade(tradeId, user.userId)
    
    return c.json({
      success: true,
      message: 'Order cancelled successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// GET /api/trading/active - Trade Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
trading.get('/active', async (c) => {
  try {
    const user = c.get('user')
    
    const trades = await tradingService.getActiveTrades(user.userId)
    
    return c.json({
      success: true,
      data: { trades },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 10000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

export default trading
```

---

## ğŸ¯ ÙØ§Ø² 5: Dashboard Comprehensive API (Ø±ÙˆØ² 9)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 1 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø§Ù„Ø§

### Task 5.1: Dashboard Service (4 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/dashboard-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import { portfolioService } from './portfolio-service'
import { tradingService } from './trading-service'
import { marketDataService } from './market-data-service'

const prisma = new PrismaClient()

export class DashboardService {
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ù…Ø¹ Dashboard
   */
  async getComprehensiveDashboard(userId: string) {
    // Ø¯Ø±ÛŒØ§ÙØª Portfolio
    const portfolio = await portfolioService.getAdvancedPortfolio(userId)
    
    // Ø¯Ø±ÛŒØ§ÙØª Trade Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
    const activeTrades = await tradingService.getActiveTrades(userId)
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
    const topSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT']
    const marketPrices = await marketDataService.fetchRealTimePrices(topSymbols)
    
    // Ø¯Ø±ÛŒØ§ÙØª Fear & Greed
    const fearGreed = await marketDataService.getFearGreedIndex()
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Trading
    const todayStart = new Date()
    todayStart.setHours(0, 0, 0, 0)
    
    const todayTrades = await prisma.trade.count({
      where: {
        userId,
        createdAt: { gte: todayStart }
      }
    })
    
    const pendingOrders = await prisma.trade.count({
      where: {
        userId,
        status: 'pending'
      }
    })
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Volume 24h
    const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000)
    const volume24h = await prisma.trade.aggregate({
      where: {
        userId,
        createdAt: { gte: last24h },
        status: 'completed'
      },
      _sum: { total: true }
    })
    
    // Ø¯Ø±ÛŒØ§ÙØª AI Agent Status
    const aiAgents = await this.getAIAgentsStatus(userId)
    
    // Ø¯Ø±ÛŒØ§ÙØª Recent Activities
    const recentActivities = await this.getRecentActivities(userId, 10)
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Risk Metrics
    const risk = await this.calculateRiskMetrics(userId, portfolio)
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Learning Progress (ÙØ¹Ù„Ø§Ù‹ mock)
    const learning = {
      totalSessions: 125,
      completedCourses: 8,
      currentLevel: 5,
      weeklyProgress: 85
    }
    
    // Chart Data
    const charts = await this.getChartsData(userId)
    
    return {
      portfolio: {
        totalBalance: portfolio.totalBalance,
        dailyChange: portfolio.dailyChange,
        weeklyChange: portfolio.weeklyChange,
        monthlyChange: portfolio.monthlyChange,
        totalPnL: portfolio.totalPnL,
        totalTrades: activeTrades.length,
        winRate: portfolio.winRate,
        sharpeRatio: portfolio.sharpeRatio,
        assets: portfolio.assets
      },
      
      trading: {
        activeTrades: activeTrades.length,
        todayTrades,
        pendingOrders,
        totalVolume24h: volume24h._sum.total || 0,
        successfulTrades: activeTrades.filter(t => t.status === 'completed').length,
        failedTrades: activeTrades.filter(t => t.status === 'failed').length
      },
      
      market: {
        btcPrice: marketPrices['BTCUSDT']?.price || 0,
        ethPrice: marketPrices['ETHUSDT']?.price || 0,
        fear_greed_index: fearGreed.value,
        dominance: 51.2, // Ø¨Ø§ÛŒØ¯ Ø§Ø² API ÙˆØ§Ù‚Ø¹ÛŒ Ú¯Ø±ÙØªÙ‡ Ø´ÙˆØ¯
        prices: marketPrices
      },
      
      risk,
      learning,
      aiAgents,
      activities: recentActivities,
      charts,
      
      summary: {
        activeAgents: aiAgents.filter(a => a.status === 'active').length,
        totalAgents: aiAgents.length,
        avgPerformance: aiAgents.reduce((sum, a) => sum + a.performance, 0) / aiAgents.length,
        systemHealth: 98.5
      },
      
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    }
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª AI Agents
   */
  async getAIAgentsStatus(userId: string) {
    // Ø§ÛŒÙ† Ø¨Ø§ÛŒØ¯ Ø§Ø² ÛŒÚ© Ø¬Ø¯ÙˆÙ„ Ù…Ø®ØµÙˆØµ AI Agent Ù‡Ø§ Ø¨ÛŒØ§ÛŒØ¯
    // ÙØ¹Ù„Ø§Ù‹ mock data
    return [
      { id: 1, name: 'Technical Analysis', status: 'active', performance: 12.3, trades: 45, uptime: 98.5 },
      { id: 2, name: 'Risk Management', status: 'active', performance: 8.7, trades: 23, uptime: 99.2 },
      { id: 3, name: 'Sentiment Analysis', status: 'active', performance: 15.4, trades: 67, uptime: 95.1 },
      { id: 4, name: 'Portfolio Optimization', status: 'active', performance: 6.2, trades: 12, uptime: 97.8 },
      { id: 5, name: 'Market Making', status: 'paused', performance: 9.8, trades: 34, uptime: 98.9 }
    ]
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
   */
  async getRecentActivities(userId: string, limit: number = 10) {
    const trades = await prisma.trade.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: limit
    })
    
    return trades.map(trade => ({
      id: trade.id,
      type: trade.type === 'buy' ? 'trade' : 'profit',
      description: `${trade.type.toUpperCase()} ${trade.symbol}`,
      amount: trade.type === 'buy' ? -trade.total : trade.total,
      timestamp: trade.createdAt.getTime(),
      agent: trade.strategy || 'Manual'
    }))
  }
  
  /**
   * Ù…Ø­Ø§Ø³Ø¨Ù‡ Risk Metrics
   */
  async calculateRiskMetrics(userId: string, portfolio: any) {
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Total Exposure
    const totalExposure = (portfolio.totalValue / (portfolio.totalBalance + portfolio.totalValue)) * 100
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Current Drawdown
    const allTimeTrades = await prisma.trade.findMany({
      where: { userId, status: 'completed' },
      orderBy: { executedAt: 'asc' }
    })
    
    let peak = portfolio.totalBalance
    let drawdown = 0
    
    for (const trade of allTimeTrades) {
      const currentValue = portfolio.totalBalance + portfolio.totalValue
      if (currentValue > peak) peak = currentValue
      drawdown = Math.min(drawdown, ((currentValue - peak) / peak) * 100)
    }
    
    // Risk Score (Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
    const riskScore = Math.min(100, Math.max(0, 
      (totalExposure * 0.4) + 
      (Math.abs(drawdown) * 0.3) + 
      (50 - portfolio.winRate) * 0.3
    ))
    
    return {
      totalExposure: Math.round(totalExposure),
      maxRiskPerTrade: 2.5,
      currentDrawdown: Number(drawdown.toFixed(2)),
      riskScore: Math.round(riskScore)
    }
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Chart
   */
  async getChartsData(userId: string) {
    // Portfolio Performance Chart (30 Ø±ÙˆØ² Ø§Ø®ÛŒØ±)
    const days = 30
    const portfolioHistory = []
    
    for (let i = days; i >= 0; i--) {
      const date = new Date()
      date.setDate(date.getDate() - i)
      
      // Ø§ÛŒÙ† Ø¨Ø§ÛŒØ¯ Ø§Ø² ÛŒÚ© Ø¬Ø¯ÙˆÙ„ History Ø¨ÛŒØ§ÛŒØ¯
      // ÙØ¹Ù„Ø§Ù‹ mock data
      portfolioHistory.push({
        date: date.toISOString().split('T')[0],
        value: 100000 + (Math.random() * 10000) - 5000
      })
    }
    
    return {
      performance: {
        labels: portfolioHistory.map(h => h.date),
        datasets: [{
          label: 'Portfolio Value',
          data: portfolioHistory.map(h => h.value),
          borderColor: 'rgb(59, 130, 246)',
          backgroundColor: 'rgba(59, 130, 246, 0.1)',
          tension: 0.4
        }]
      },
      
      agents: {
        labels: ['Agent 1', 'Agent 2', 'Agent 3', 'Agent 4', 'Agent 5'],
        datasets: [{
          label: 'Performance (%)',
          data: [12.3, 8.7, 15.4, 6.2, 9.8],
          backgroundColor: 'rgba(59, 130, 246, 0.8)'
        }]
      },
      
      volume: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [{
          label: 'Trading Volume ($)',
          data: [15000, 18000, 12000, 22000, 19000, 16000, 20000],
          backgroundColor: 'rgba(16, 185, 129, 0.8)'
        }]
      }
    }
  }
}

export const dashboardService = new DashboardService()
```

### Task 5.2: Dashboard Routes (1 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/dashboard.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { dashboardService } from '../services/dashboard-service'

const dashboard = new Hono()

dashboard.use('*', authMiddleware)

// GET /api/dashboard/comprehensive-real
dashboard.get('/comprehensive-real', async (c) => {
  try {
    const user = c.get('user')
    
    const data = await dashboardService.getComprehensiveDashboard(user.userId)
    
    return c.json({
      success: true,
      data
    })
  } catch (error: any) {
    console.error('Dashboard error:', error)
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// GET /api/dashboard/stats - Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ø®Ù„Ø§ØµÙ‡
dashboard.get('/stats', async (c) => {
  try {
    const user = c.get('user')
    const data = await dashboardService.getComprehensiveDashboard(user.userId)
    
    return c.json({
      success: true,
      data: {
        totalBalance: data.portfolio.totalBalance,
        dailyChange: data.portfolio.dailyChange,
        activeTrades: data.trading.activeTrades,
        todayTrades: data.trading.todayTrades
      },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 10000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

export default dashboard
```

---

## ğŸ¯ ÙØ§Ø² 6: AI Agents Backend (Ø±ÙˆØ² 10-12)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 3 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸŸ¡ Ù…ØªÙˆØ³Ø·

### Task 6.1: AI Agent Service (Ø¨Ø®Ø´ Ù¾Ø§ÛŒÙ‡ - 4 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/ai-agent-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import { marketDataService } from './market-data-service'
import { tradingService } from './trading-service'

const prisma = new PrismaClient()

export class AIAgentService {
  /**
   * Ø«Ø¨Øª Signal Ø§Ø² Agent
   */
  async recordSignal(data: {
    agentId: string
    symbol: string
    action: 'buy' | 'sell' | 'hold'
    confidence: number
    price: number
    reason?: string
    indicators?: any
  }) {
    return await prisma.aISignal.create({
      data: {
        ...data,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
      }
    })
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Signal Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
   */
  async getActiveSignals(symbol?: string) {
    const where: any = {
      isValid: true,
      expiresAt: { gt: new Date() }
    }
    
    if (symbol) {
      where.symbol = symbol
    }
    
    return await prisma.aISignal.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: 50
    })
  }
  
  /**
   * Ø§Ø¬Ø±Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Signal
   */
  async executeSignal(signalId: string, userId: string) {
    const signal = await prisma.aISignal.findUnique({
      where: { id: signalId }
    })
    
    if (!signal || !signal.isValid) {
      throw new Error('Invalid signal')
    }
    
    if (signal.action === 'hold') {
      throw new Error('Cannot execute HOLD signal')
    }
    
    // Ø«Ø¨Øª Trade
    const trade = await tradingService.placeTrade(userId, {
      type: signal.action,
      symbol: signal.symbol,
      amount: 0.1, // Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ - Ø¨Ø§ÛŒØ¯ Ù‚Ø§Ø¨Ù„ ØªÙ†Ø¸ÛŒÙ… Ø¨Ø§Ø´Ø¯
      orderType: 'market',
      strategy: `ai_${signal.agentId}`,
      agentId: signal.agentId
    })
    
    // ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Signal
    await prisma.aISignal.update({
      where: { id: signalId },
      data: { isValid: false }
    })
    
    return trade
  }
  
  /**
   * Technical Analysis Agent
   */
  async runTechnicalAnalysis(symbol: string) {
    // Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ
    const prices = await marketDataService.fetchRealTimePrices([symbol])
    const price = prices[symbol]
    
    if (!price) {
      throw new Error('Unable to fetch price data')
    }
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ (Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
    const rsi = this.calculateRSI([price.price]) // Ø¨Ø§ÛŒØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ø§Ø´Ø¯
    const macd = this.calculateMACD([price.price])
    
    // ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ
    let action: 'buy' | 'sell' | 'hold' = 'hold'
    let confidence = 0.5
    
    if (rsi < 30 && macd > 0) {
      action = 'buy'
      confidence = 0.8
    } else if (rsi > 70 && macd < 0) {
      action = 'sell'
      confidence = 0.8
    }
    
    // Ø«Ø¨Øª Signal
    return await this.recordSignal({
      agentId: 'AGENT_01_TECHNICAL_ANALYSIS',
      symbol,
      action,
      confidence,
      price: price.price,
      reason: `RSI: ${rsi.toFixed(2)}, MACD: ${macd > 0 ? 'Bullish' : 'Bearish'}`,
      indicators: { rsi, macd }
    })
  }
  
  /**
   * Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI (Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
   */
  private calculateRSI(prices: number[]): number {
    // Ø§ÛŒÙ† ÛŒÚ© Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡ Ø§Ø³Øª - Ø¨Ø§ÛŒØ¯ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø´ÙˆØ¯
    return 50 + (Math.random() * 40) - 20
  }
  
  /**
   * Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD (Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
   */
  private calculateMACD(prices: number[]): number {
    // Ø§ÛŒÙ† ÛŒÚ© Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡ Ø§Ø³Øª - Ø¨Ø§ÛŒØ¯ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø´ÙˆØ¯
    return (Math.random() - 0.5) * 10
  }
}

export const aiAgentService = new AIAgentService()
```

### Task 6.2: AI Agent Routes (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/ai-agents.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { aiAgentService } from '../services/ai-agent-service'

const aiAgents = new Hono()

aiAgents.use('*', authMiddleware)

// GET /api/ai-agents/signals - Ø¯Ø±ÛŒØ§ÙØª Signal Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
aiAgents.get('/signals', async (c) => {
  try {
    const symbol = c.req.query('symbol')
    
    const signals = await aiAgentService.getActiveSignals(symbol)
    
    return c.json({
      success: true,
      data: { signals },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 5000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// POST /api/ai-agents/analyze - Ø§Ø¬Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„
aiAgents.post('/analyze', async (c) => {
  try {
    const { symbol, agentId } = await c.req.json()
    
    let signal
    
    switch (agentId) {
      case 'AGENT_01_TECHNICAL_ANALYSIS':
        signal = await aiAgentService.runTechnicalAnalysis(symbol)
        break
      
      // Ø³Ø§ÛŒØ± Agent Ù‡Ø§...
      
      default:
        throw new Error('Unknown agent')
    }
    
    return c.json({
      success: true,
      data: { signal }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// POST /api/ai-agents/execute/:signalId - Ø§Ø¬Ø±Ø§ÛŒ Signal
aiAgents.post('/execute/:signalId', async (c) => {
  try {
    const user = c.get('user')
    const signalId = c.req.param('signalId')
    
    const trade = await aiAgentService.executeSignal(signalId, user.userId)
    
    return c.json({
      success: true,
      data: { trade },
      message: 'Signal executed successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

export default aiAgents
```

---

## ğŸ¯ ÙØ§Ø² 7: Alerts & Notifications (Ø±ÙˆØ² 13-14)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 2 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸŸ¡ Ù…ØªÙˆØ³Ø·

### Task 7.1: Alerts Service (4 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/services/alerts-service.ts`

```typescript
import { PrismaClient } from '@prisma/client'
import { marketDataService } from './market-data-service'

const prisma = new PrismaClient()

export class AlertsService {
  /**
   * Ø§ÛŒØ¬Ø§Ø¯ Alert Ø¬Ø¯ÛŒØ¯
   */
  async createAlert(userId: string, data: {
    type: 'price' | 'indicator' | 'news'
    symbol?: string
    condition: 'above' | 'below' | 'crosses'
    targetValue?: number
    message?: string
  }) {
    return await prisma.alert.create({
      data: {
        userId,
        ...data
      }
    })
  }
  
  /**
   * Ø¯Ø±ÛŒØ§ÙØª Alert Ù‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
   */
  async getUserAlerts(userId: string, isActive?: boolean) {
    const where: any = { userId }
    
    if (isActive !== undefined) {
      where.isActive = isActive
    }
    
    return await prisma.alert.findMany({
      where,
      orderBy: { createdAt: 'desc' }
    })
  }
  
  /**
   * Ú†Ú© Ú©Ø±Ø¯Ù† Alert Ù‡Ø§ (Ø¨Ø§ÛŒØ¯ Ù‡Ø± Ú†Ù†Ø¯ Ø«Ø§Ù†ÛŒÙ‡ Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯)
   */
  async checkAlerts() {
    // Ø¯Ø±ÛŒØ§ÙØª Alert Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
    const alerts = await prisma.alert.findMany({
      where: {
        isActive: true,
        isTriggered: false
      }
    })
    
    for (const alert of alerts) {
      try {
        await this.checkSingleAlert(alert)
      } catch (error) {
        console.error(`Error checking alert ${alert.id}:`, error)
      }
    }
  }
  
  /**
   * Ú†Ú© Ú©Ø±Ø¯Ù† ÛŒÚ© Alert
   */
  private async checkSingleAlert(alert: any) {
    if (alert.type !== 'price' || !alert.symbol) {
      return
    }
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
    const prices = await marketDataService.fetchRealTimePrices([alert.symbol])
    const currentPrice = prices[alert.symbol]?.price
    
    if (!currentPrice) {
      return
    }
    
    // Ú†Ú© Ú©Ø±Ø¯Ù† Ø´Ø±Ø·
    let triggered = false
    
    switch (alert.condition) {
      case 'above':
        triggered = currentPrice > (alert.targetValue || 0)
        break
      case 'below':
        triggered = currentPrice < (alert.targetValue || 0)
        break
      case 'crosses':
        // Ø¨Ø§ÛŒØ¯ Ù‚ÛŒÙ…Øª Ù‚Ø¨Ù„ÛŒ Ø±Ø§ Ú†Ú© Ú©Ù†Ø¯
        break
    }
    
    if (triggered) {
      // ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Alert
      await prisma.alert.update({
        where: { id: alert.id },
        data: {
          isTriggered: true,
          triggeredAt: new Date(),
          currentValue: currentPrice
        }
      })
      
      // Ø§Ø±Ø³Ø§Ù„ Notification (Ø¨Ø§ÛŒØ¯ Ù¾ÛŒØ§Ø¯Ù‡ Ø´ÙˆØ¯)
      console.log(`ğŸ”” Alert triggered: ${alert.symbol} ${alert.condition} ${alert.targetValue}`)
    }
  }
  
  /**
   * Ø­Ø°Ù Alert
   */
  async deleteAlert(alertId: string, userId: string) {
    const alert = await prisma.alert.findFirst({
      where: { id: alertId, userId }
    })
    
    if (!alert) {
      throw new Error('Alert not found')
    }
    
    await prisma.alert.delete({
      where: { id: alertId }
    })
  }
}

export const alertsService = new AlertsService()
```

### Task 7.2: Alerts Routes (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/routes/alerts.ts`

```typescript
import { Hono } from 'hono'
import { authMiddleware } from '../middleware/auth'
import { alertsService } from '../services/alerts-service'

const alerts = new Hono()

alerts.use('*', authMiddleware)

// GET /api/alerts - Ø¯Ø±ÛŒØ§ÙØª Alert Ù‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
alerts.get('/', async (c) => {
  try {
    const user = c.get('user')
    const isActive = c.req.query('active') === 'true' ? true : undefined
    
    const data = await alertsService.getUserAlerts(user.userId, isActive)
    
    return c.json({
      success: true,
      data: { alerts: data },
      meta: {
        source: 'real',
        ts: Date.now(),
        ttlMs: 30000,
        stale: false
      }
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 500)
  }
})

// POST /api/alerts - Ø§ÛŒØ¬Ø§Ø¯ Alert
alerts.post('/', async (c) => {
  try {
    const user = c.get('user')
    const body = await c.req.json()
    
    const alert = await alertsService.createAlert(user.userId, body)
    
    return c.json({
      success: true,
      data: { alert },
      message: 'Alert created successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

// DELETE /api/alerts/:id - Ø­Ø°Ù Alert
alerts.delete('/:id', async (c) => {
  try {
    const user = c.get('user')
    const alertId = c.req.param('id')
    
    await alertsService.deleteAlert(alertId, user.userId)
    
    return c.json({
      success: true,
      message: 'Alert deleted successfully'
    })
  } catch (error: any) {
    return c.json({
      success: false,
      error: error.message
    }, 400)
  }
})

export default alerts
```

---

## ğŸ¯ ÙØ§Ø² 8: Integration & Testing (Ø±ÙˆØ² 15-17)

**Ù…Ø¯Øª Ø²Ù…Ø§Ù†**: 3 Ø±ÙˆØ²  
**Ø§ÙˆÙ„ÙˆÛŒØª**: ğŸ”´ Ø¨Ø§Ù„Ø§

### Task 8.1: Ø§ØªØµØ§Ù„ Ù‡Ù…Ù‡ Routes Ø¨Ù‡ Main App (2 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/index.tsx`

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'

// Import Routes
import authRoutes from './routes/auth'
import portfolioRoutes from './routes/portfolio'
import marketRoutes from './routes/market'
import tradingRoutes from './routes/trading'
import dashboardRoutes from './routes/dashboard'
import aiAgentsRoutes from './routes/ai-agents'
import alertsRoutes from './routes/alerts'

const app = new Hono()

// CORS
app.use('*', cors({
  origin: ['http://localhost:3000', 'https://www.zala.ir'],
  credentials: true
}))

// Health Check
app.get('/api/health', (c) => {
  return c.json({
    status: 'ok',
    timestamp: Date.now(),
    service: 'Titan Trading System'
  })
})

// Mount Routes
app.route('/api/auth', authRoutes)
app.route('/api/portfolio', portfolioRoutes)
app.route('/api/market', marketRoutes)
app.route('/api/trading', tradingRoutes)
app.route('/api/dashboard', dashboardRoutes)
app.route('/api/ai-agents', aiAgentsRoutes)
app.route('/api/alerts', alertsRoutes)

// Error Handler
app.onError((err, c) => {
  console.error('âŒ Server error:', err)
  return c.json({
    success: false,
    error: 'Internal server error',
    message: err.message
  }, 500)
})

// 404 Handler
app.notFound((c) => {
  return c.json({
    success: false,
    error: 'Not found',
    path: c.req.path
  }, 404)
})

export default app
```

### Task 8.2: Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Background Jobs (3 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `src/jobs/index.ts`

```typescript
import { marketDataService } from '../services/market-data-service'
import { alertsService } from '../services/alerts-service'
import { portfolioService } from '../services/portfolio-service'

/**
 * Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ (Ù‡Ø± 10 Ø«Ø§Ù†ÛŒÙ‡)
 */
export async function updateMarketPricesJob() {
  console.log('ğŸ”„ Updating market prices...')
  
  const symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'ADAUSDT', 'DOTUSDT']
  
  try {
    await marketDataService.fetchRealTimePrices(symbols)
    console.log('âœ… Market prices updated')
  } catch (error) {
    console.error('âŒ Failed to update prices:', error)
  }
}

/**
 * Ú†Ú© Ú©Ø±Ø¯Ù† Alert Ù‡Ø§ (Ù‡Ø± 30 Ø«Ø§Ù†ÛŒÙ‡)
 */
export async function checkAlertsJob() {
  console.log('ğŸ”” Checking alerts...')
  
  try {
    await alertsService.checkAlerts()
    console.log('âœ… Alerts checked')
  } catch (error) {
    console.error('âŒ Failed to check alerts:', error)
  }
}

/**
 * Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù‡Ù…Ù‡ Job Ù‡Ø§
 */
export function startBackgroundJobs() {
  console.log('ğŸš€ Starting background jobs...')
  
  // Update prices every 10 seconds
  setInterval(updateMarketPricesJob, 10000)
  
  // Check alerts every 30 seconds
  setInterval(checkAlertsJob, 30000)
  
  console.log('âœ… Background jobs started')
}
```

Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ `src/index.tsx`:

```typescript
import { startBackgroundJobs } from './jobs'

// Ø¯Ø± Ø§Ù†ØªÙ‡Ø§ÛŒ ÙØ§ÛŒÙ„:
startBackgroundJobs()
```

### Task 8.3: Ù†ÙˆØ´ØªÙ† ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ (4 Ø³Ø§Ø¹Øª)

**ÙØ§ÛŒÙ„**: `tests/auth.test.ts`

```typescript
import { describe, it, expect } from '@jest/globals'
import app from '../src/index'

describe('Authentication', () => {
  it('should register new user', async () => {
    const res = await app.request('/api/auth/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      })
    })
    
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.success).toBe(true)
  })
  
  it('should login user', async () => {
    const res = await app.request('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        username: 'admin',
        password: 'admin'
      })
    })
    
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.success).toBe(true)
    expect(data.data.token).toBeDefined()
  })
})
```

**ÙØ§ÛŒÙ„**: `tests/portfolio.test.ts`

```typescript
describe('Portfolio', () => {
  let authToken: string
  
  beforeAll(async () => {
    // Login first
    const res = await app.request('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        username: 'admin',
        password: 'admin'
      })
    })
    
    const data = await res.json()
    authToken = data.data.token
  })
  
  it('should get portfolio', async () => {
    const res = await app.request('/api/portfolio', {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    })
    
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.success).toBe(true)
    expect(data.data).toBeDefined()
  })
  
  it('should get advanced portfolio', async () => {
    const res = await app.request('/api/portfolio/advanced', {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    })
    
    expect(res.status).toBe(200)
    const data = await res.json()
    expect(data.success).toBe(true)
    expect(data.data.totalBalance).toBeDefined()
  })
})
```

Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§:

```bash
npm test
```

---

## ğŸ“ Ø®Ù„Ø§ØµÙ‡ Ú©Ø§Ù…Ù„ - Ú†Ú© Ù„ÛŒØ³Øª Ù†Ù‡Ø§ÛŒÛŒ

### âœ… ÙØ§Ø² 1: Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ (Ø±ÙˆØ² 1)
- [ ] Setup Database Schema (Prisma)
- [ ] Ø§Ø¬Ø±Ø§ÛŒ Migration
- [ ] Seed Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
- [ ] Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Authentication System
- [ ] Ø§ÛŒØ¬Ø§Ø¯ Auth Middleware
- [ ] ØªØ³Øª Login/Register

### âœ… ÙØ§Ø² 2: Portfolio APIs (Ø±ÙˆØ² 2-3)
- [ ] Portfolio Service
- [ ] Portfolio Routes
- [ ] Advanced Portfolio Endpoint
- [ ] Transactions Endpoint
- [ ] Asset Management
- [ ] Price Update System

### âœ… ÙØ§Ø² 3: Market Data APIs (Ø±ÙˆØ² 4-5)
- [ ] ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ Binance API
- [ ] Market Prices Endpoint
- [ ] Fear & Greed Index
- [ ] Trending Coins
- [ ] News API Integration
- [ ] Market Data Caching

### âœ… ÙØ§Ø² 4: Trading Engine (Ø±ÙˆØ² 6-8)
- [ ] Trading Service
- [ ] Place Order Endpoint
- [ ] Execute Trade Logic
- [ ] Cancel Order Endpoint
- [ ] Active Trades Endpoint
- [ ] Order Types (Market, Limit, Stop Loss)

### âœ… ÙØ§Ø² 5: Dashboard API (Ø±ÙˆØ² 9)
- [ ] Dashboard Service
- [ ] Comprehensive Dashboard Endpoint
- [ ] Stats Endpoint
- [ ] Charts Data
- [ ] Risk Metrics
- [ ] Recent Activities

### âœ… ÙØ§Ø² 6: AI Agents (Ø±ÙˆØ² 10-12)
- [ ] AI Agent Service (Ù¾Ø§ÛŒÙ‡)
- [ ] Signal System
- [ ] Technical Analysis Agent
- [ ] Signal Execution
- [ ] Agent Routes
- [ ] Agent Status Tracking

### âœ… ÙØ§Ø² 7: Alerts (Ø±ÙˆØ² 13-14)
- [ ] Alerts Service
- [ ] Create Alert Endpoint
- [ ] Get Alerts Endpoint
- [ ] Delete Alert Endpoint
- [ ] Alert Checking Job
- [ ] Notification System (Ù¾Ø§ÛŒÙ‡)

### âœ… ÙØ§Ø² 8: Integration & Testing (Ø±ÙˆØ² 15-17)
- [ ] Ø§ØªØµØ§Ù„ Ù‡Ù…Ù‡ Routes
- [ ] Background Jobs Setup
- [ ] Market Prices Update Job
- [ ] Alerts Check Job
- [ ] Ù†ÙˆØ´ØªÙ† Unit Tests
- [ ] Ù†ÙˆØ´ØªÙ† Integration Tests
- [ ] Testing Ø¨Ø§ Frontend
- [ ] Performance Optimization
- [ ] Documentation

---

## ğŸš€ Ù†ØªÛŒØ¬Ù‡ Ù†Ù‡Ø§ÛŒÛŒ

Ø¨Ø¹Ø¯ Ø§Ø² ØªÚ©Ù…ÛŒÙ„ Ù‡Ù…Ù‡ Ø§ÛŒÙ† ÙØ§Ø²Ù‡Ø§:

### âœ… Backend Ú©Ø§Ù…Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯:
- 40+ API Endpoint Ú©Ø§Ù…Ù„Ø§Ù‹ Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ
- Authentication & Authorization Ú©Ø§Ù…Ù„
- Real-time Market Data
- Trading Engine Ú©Ø§Ù…Ù„
- AI Agents Ù¾Ø§ÛŒÙ‡ (Ù‚Ø§Ø¨Ù„ ØªÙˆØ³Ø¹Ù‡)
- Alerts & Notifications
- Dashboard Comprehensive

### âœ… Frontend Ú©Ø§Ù…Ù„Ø§Ù‹ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯:
- Login/Register âœ…
- Dashboard Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ âœ…
- Portfolio Tracking âœ…
- Trading Interface âœ…
- AI Agents Display âœ…
- Market Data Real-time âœ…
- Charts & Analytics âœ…
- Alerts Management âœ…

### âœ… ØªØ¬Ø±Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¹Ø§Ù„ÛŒ:
- Ø³Ø±Ø¹Øª Ø¨Ø§Ù„Ø§
- Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Real-time
- Ø¹Ø¯Ù… Ø®Ø·Ø§ÛŒ 404
- UI/UX Ø±ÙˆØ§Ù†
- Ú©Ø§Ù…Ù„Ø§Ù‹ Production-ready

---

**ØªØ®Ù…ÛŒÙ† Ø²Ù…Ø§Ù† Ú©Ù„**: 2-3 Ù‡ÙØªÙ‡ (Full-time)  
**ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Task Ù‡Ø§**: 67 Task  
**ØªØ¹Ø¯Ø§Ø¯ API Endpoints**: 40+  
**ÙˆØ¶Ø¹ÛŒØª Ù†Ù‡Ø§ÛŒÛŒ**: â­â­â­â­â­ Production Ready

---

**Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…**: Ø§ÛŒÙ† Ù†Ù‚Ø´Ù‡ Ø±Ø§Ù‡ Ú©Ø§Ù…Ù„ Ø§Ø³Øª Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª ØªØ¯Ø±ÛŒØ¬ÛŒ Ù¾ÛŒØ´ Ø¨Ø±ÙˆÛŒØ¯. Ø§Ø¨ØªØ¯Ø§ ÙØ§Ø²Ù‡Ø§ÛŒ 1-5 Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯ ØªØ§ Ø³Ø§ÛŒØª Ø§ØµÙ„ÛŒ Ú©Ø§Ø± Ú©Ù†Ø¯ØŒ Ø³Ù¾Ø³ ÙØ§Ø²Ù‡Ø§ÛŒ 6-8 Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù…Ù„â€ŒØªØ± Ø´Ø¯Ù†.

Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ø² Ù‡Ø± ÙØ§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒÙ…ØŸ ğŸš€
